---
author: Bert van der Weerd
email: bert@stanzabird.nl
git_username: stanzabird
---

{% project "autotools.minimal.c" %}

{% file "configure.ac" %}
AC_INIT([{{project_name}}], [0.1.0], [{{email}}], [], [https://github.com/{{git_username}}/{{project_name}}/])
AC_CONFIG_SRCDIR({{project_name}}.c)
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
AC_PROG_CC

AC_CONFIG_FILES(Makefile)
AC_OUTPUT
{% endfile %}

{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
bin_PROGRAMS = {{project_name}}
{{project_name}}_SOURCES = {{project_name}}.c
{% endfile %}

{% file "${pn}.c" %}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc,char* argv[]) {
  return 0;
}
{% endfile %}
{% endproject %}







{% project "autotools.minimal.c++" %}

{% file "configure.ac" %}
AC_INIT([{{project_name}}], [0.1.0], [{{email}}], [], [https://github.com/{{git_username}}/{{project_name}}/])
AC_CONFIG_SRCDIR({{project_name}}.cc)
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
AC_PROG_CXX

AC_CONFIG_FILES(Makefile)
AC_OUTPUT
{% endfile %}

{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
bin_PROGRAMS = {{project_name}}
{{project_name}}_SOURCES = {{project_name}}.cc
{% endfile %}

{% file "${pn}.cc" %}
#include <iostream>
#include <vector>
#include <string>

int main(int argc,char* argv[]) {
  return 0;
}
{% endfile %}
{% endproject %}





{% project "autotools.getopt.c" %}


{% file "configure.ac" %}
AC_INIT([{{project_name}}], [0.1.0], [{{email}}], [], [https://github.com/{{git_username}}/{{project_name}}/])
AC_CONFIG_SRCDIR(src/{{project_name}}.c)
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
AC_PROG_CC

AC_CONFIG_FILES(Makefile src/Makefile)
AC_OUTPUT
{% endfile %}

{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
SUBDIRS = src
{% module vs %}
EXTRA_DIST = vs/build.bat vs/src/getopt.h vs/src/getopt.c vs/src/getopt_long.c
{% endmodule %}
{% endfile %}

{% file "src/Makefile.am" %}
bin_PROGRAMS = {{project_name}}
{{project_name}}_SOURCES = {{project_name}}.h {{project_name}}.c
{% module man %}

man_MANS = {{ project_name }}.1

man :
	nroff -man {{ project_name }}.1 | less

EXTRA_DIST = $(man_MANS)
{% endmodule %}
{% endfile %}

{% module man %}
{% file snippet manpage "src/${pn}.1" %}
{% endmodule %}

{% file "src/${pn}.h" %}
#ifndef INCLUDED_{{ project_name | upcase }}_H
#define INCLUDED_{{ project_name | upcase }}_H

/* program options */
struct {{ project_name }}_options
{
  int verbose;
};

#endif
{% endfile %}

{% file "src/${pn}.c" %}
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "{{project_name}}.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include <getopt.h>

enum
{
  GETOPT_HELP_CHAR = (CHAR_MIN - 2),
  GETOPT_VERSION_CHAR = (CHAR_MIN - 3)
};

#define GETOPT_HELP_OPTION_DECL			\
  "help", no_argument, NULL, GETOPT_HELP_CHAR
#define GETOPT_VERSION_OPTION_DECL \
  "version", no_argument, NULL, GETOPT_VERSION_CHAR

static struct option const long_options[] =
  {
    {"verbose",no_argument,NULL,'v'},
    {GETOPT_HELP_OPTION_DECL},
    {GETOPT_VERSION_OPTION_DECL},
    {NULL,0,NULL,0}
  };

static void {{ project_name }}_options_init(struct {{ project_name }}_options *x) {
  x->verbose = 0;
}


static void usage() {
  printf("{{ project_name }} [OPTION]... SOURCE...\n\n");

  printf(
    "  -v, --verbose  explain what's being done\n"
    "      --help     display this help and exit\n"
    "      --version  output version information and exit\n"
    );

  printf(
    "\n"
    "Use this program to ... This place is used to explain the use\n"
    "of this program in one or two simple to read paragraphs.\n"
    "\n"
    );
}

static void version() {
  printf(
    "{{ project_name }} (" PACKAGE_NAME ") " PACKAGE_VERSION "\n"
    "Copyright (C) {{ year }} {{ author }} <{{ email }}>\n"
    "Licence GPLv2+\n"
    "This is free software; you are free to change and redistribute it.\n"
    "There is NO WARANTY, to the extent permitted by law.\n"
    );
}



int main(int argc, char* argv[]) {
  int c;
  struct {{ project_name }}_options x;
  
  {{ project_name }}_options_init(&x);

  // if we just type the command, we want help.
  if (argc == 1) {
    usage();
    return EXIT_SUCCESS;
  }
  
  while ((c = getopt_long(argc,argv,"v",long_options, NULL)) != -1)
    {
      switch (c)
	{
	case 'v':
	  x.verbose = 1;
	  break;
	  
	case GETOPT_HELP_CHAR:
	  usage();
	  return EXIT_SUCCESS;
	  
	case GETOPT_VERSION_CHAR:
	  version();
	  return EXIT_SUCCESS;

        case '?':
	  return EXIT_FAILURE; // getopt_long() already printed an error message
	  
	default:
	  usage();
	  return EXIT_FAILURE;
	}
    }

  if (argc - optind < 1)
    {
      printf(
        "{{ project_name }}: missing file operands\n"
        "Try '{{ project_name }} --help' for more information.\n"
	);
      return EXIT_FAILURE;
    }

  // todo: implement the program

  return EXIT_SUCCESS;
}
{% endfile %}

{% module vs %}
{% file "vs/build.bat" %}
MSBuild {{project_name}}.sln /target:Rebuild /property:Configuration=Release /property:Platform=x64
{% endfile %}

{% file snippet getopt_h "vs/src/getopt.h" %}
{% file snippet getopt_c "vs/src/getopt.c" %}
{% file snippet getopt_long_c "vs/src/getopt_long.c" %}
{% endmodule %}

{% endproject %}




{% project "autotools.getopt.c++" %}

{% file "configure.ac" %}
AC_INIT([{{project_name}}], [0.1.0], [{{email}}], [], [https://github.com/{{git_username}}/{{project_name}}/])
AC_CONFIG_SRCDIR(src/{{project_name}}.cc)
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
AC_PROG_CXX

AC_CONFIG_FILES(Makefile src/Makefile)
AC_OUTPUT
{% endfile %}

{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
SUBDIRS = src
{% module vs %}
EXTRA_DIST = vs/build.bat vs/src/getopt.h vs/src/getopt.c vs/src/getopt_long.c
{% endmodule %}
{% endfile %}

{% file "src/Makefile.am" %}
bin_PROGRAMS = {{project_name}}
{{project_name}}_SOURCES = {{project_name}}.h {{project_name}}.cc
{% module man %}

man_MANS = {{ project_name }}.1

man :
	nroff -man {{ project_name }}.1 | less

EXTRA_DIST = $(man_MANS)
{% endmodule %}
{% endfile %}

{% module man %}
{% file snippet manpage "src/${pn}.1" %}
{% endmodule %}

{% file "src/${pn}.h" %}
#ifndef INCLUDED_{{ project_name | upcase }}_H
#define INCLUDED_{{ project_name | upcase }}_H

/* program options */
struct {{ project_name }}_options
{
  int verbose;
};

#endif
{% endfile %}

{% file "src/${pn}.cc" %}
#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "{{project_name}}.h"

#include <iostream>
#include <vector>
#include <string>
#include <climits>

#include <getopt.h>

enum
{
  GETOPT_HELP_CHAR = (CHAR_MIN - 2),
  GETOPT_VERSION_CHAR = (CHAR_MIN - 3)
};

#define GETOPT_HELP_OPTION_DECL			\
  "help", no_argument, nullptr, GETOPT_HELP_CHAR
#define GETOPT_VERSION_OPTION_DECL \
  "version", no_argument, nullptr, GETOPT_VERSION_CHAR

static struct option const long_options[] =
  {
    {"verbose",no_argument,nullptr,'v'},
    {GETOPT_HELP_OPTION_DECL},
    {GETOPT_VERSION_OPTION_DECL},
    {nullptr,0,nullptr,0}
  };

static void {{ project_name }}_options_init(struct {{ project_name }}_options *x) {
  x->verbose = 0;
}


static void usage() {
  std::cout << "{{ project_name }} [OPTION]... SOURCE...\n\n";

  std::cout
    << "  -v, --verbose  explain what's being done\n"
    << "      --help     display this help and exit\n"
    << "      --version  output version information and exit\n"
    ;

  std::cout << "\n";
  std::cout << "Use this program to ... This place is used to explain the use\n";
  std::cout << "of this program in one or two simple to read paragraphs.\n";
  std::cout << "\n";
}

static void version() {
  std::cout << "{{ project_name }} (" PACKAGE_NAME ") " PACKAGE_VERSION "\n";
  std::cout << "Copyright (C) {{ year }} {{ author }} <{{ email }}>\n";
  std::cout << "Licence GPLv2+\n";
  std::cout << "This is free software; you are free to change and redistribute it.\n";
  std::cout << "There is NO WARANTY, to the extent permitted by law.\n";
}



int main(int argc, char* argv[]) {
  int c;
  struct {{ project_name }}_options x;
  
  {{ project_name }}_options_init(&x);

  // if we just type the command, we want help.
  if (argc == 1) {
    usage();
    return EXIT_SUCCESS;
  }
  
  while ((c = getopt_long(argc,argv,"v",long_options, NULL)) != -1)
    {
      switch (c)
	{
	case 'v':
	  x.verbose = 1;
	  break;
	  
	case GETOPT_HELP_CHAR:
	  usage();
	  return EXIT_SUCCESS;
	  
	case GETOPT_VERSION_CHAR:
	  version();
	  return EXIT_SUCCESS;

        case '?':
	  return EXIT_FAILURE; // getopt_long() already printed an error message
	  
	default:
	  usage();
	  return EXIT_FAILURE;
	}
    }

  if (argc - optind < 1)
    {
      std::cout << "{{ project_name }}: missing file operands\n";
      std::cout << "Try '{{ project_name }} --help' for more information.\n";
      return EXIT_FAILURE;
    }


  std::vector<std::string> args(argv + optind, argv + argc);
  auto functionality = [](std::vector<std::string> args, {{project_name}}_options* x){
  };  
  functionality(args,&x);


  return EXIT_SUCCESS;
}
{% endfile %}

{% module vs %}
{% file "vs/build.bat" %}
MSBuild {{project_name}}.sln /target:Rebuild /property:Configuration=Release /property:Platform=x64
{% endfile %}

{% file snippet getopt_h "vs/src/getopt.h" %}
{% file snippet getopt_c "vs/src/getopt.c" %}
{% file snippet getopt_long_c "vs/src/getopt_long.c" %}
{% endmodule %}

{% endproject %}






{% project "autotools.boost.c++" %}
  {% comment %}
    autoconf + getopt + boost + c++17
  {% endcomment %}
{% endproject %}










{% project "autotools.gtk4.c" %}
  {% comment %}
    GKT4 + autoconf + c
  {% endcomment %}



{% file "configure.ac" %}
AC_INIT([{{project_name}}], [0.1.0], [{{email}}], [], [https://github.com/{{git_username}}/{{project_name}}/])
AC_CONFIG_SRCDIR({{project_name}}.c)
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
AC_PROG_CC

AC_CONFIG_FILES(Makefile)
AC_OUTPUT
{% endfile %}

{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
bin_PROGRAMS = {{project_name}}
{{project_name}}_SOURCES = {{project_name}}.c
{{project_name}}_CPPFLAGS = `pkg-config --cflags gtk4`
{{project_name}}_LDFLAGS = `pkg-config --libs gtk4`
{% endfile %}

{% file "${pn}.c" %}
#include <gtk/gtk.h>

static void
print_hello (GtkWidget *widget,
	     gpointer   data)
{
  g_print ("Hello World\n");
}

static void
activate (GtkApplication *app,
	  gpointer        user_data)
{
  GtkWidget *window;
  GtkWidget *button, *button2;
  GtkWidget *box, *box2, *box3;

  window = gtk_application_window_new (app);
  gtk_window_set_title (GTK_WINDOW (window), "HEYYYY");
  gtk_window_set_default_size (GTK_WINDOW (window), 400, 200);

  box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
  box2 = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
  box3 = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
  
  gtk_window_set_child (GTK_WINDOW (window), box3);

  button = gtk_button_new_with_label ("Hello World");
  button2 = gtk_button_new_with_label ("i am button 2");
  
  g_signal_connect (button, "clicked", G_CALLBACK (print_hello), NULL);
  g_signal_connect_swapped (button, "clicked", G_CALLBACK (gtk_window_destroy), window);
  gtk_box_append (GTK_BOX (box), button);
  gtk_box_append (GTK_BOX (box2), button2);
  gtk_box_append (GTK_BOX (box3), box2);
  gtk_box_append (GTK_BOX (box3), box);

  gtk_widget_show (window);
}

int
main (int    argc,
      char **argv)
{
  GtkApplication *app;
  int status;

  app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
  g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
  status = g_application_run (G_APPLICATION (app), argc, argv);
  g_object_unref (app);

  return status;
}
{% endfile %}



{% endproject %}










{% project "autotools.gtk4.c++" %}
  {% comment %}
    GTK4 + autoconf + boost + c++17
  {% endcomment %}
{% endproject %}







{% project "autotools.sdl.c++" %}
  {% comment %}
    OpenGL/Vulkan + SDL + autoconf + getopt + boost + c++17
  {% endcomment %}
{% endproject %}










{% snippet getopt_h %}
#ifndef __GETOPT_H__
#define __GETOPT_H__

#ifdef __cplusplus
extern "C" {
#endif

extern int opterr;		/* if error message should be printed */
extern int optind;		/* index into parent argv vector */
extern int optopt;		/* character checked for validity */
extern int optreset;		/* reset getopt */
extern char *optarg;		/* argument associated with option */

struct option
{
  const char *name;
  int has_arg;
  int *flag;
  int val;
};

#define no_argument       0
#define required_argument 1
#define optional_argument 2

int getopt(int, char**, char*);
int getopt_long(int, char**, const char*, struct option*, int*);

#ifdef __cplusplus
}
#endif

#endif /* __GETOPT_H__ */
{% endsnippet %}

{% snippet getopt_c %}
#pragma warning (disable : 6011)

/*	$NetBSD: getopt.c,v 1.16 1999/12/02 13:15:56 kleink Exp $	*/

/*
 * Copyright (c) 1987, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if 0
static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
#endif

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>

#define __P(x) x
#define _DIAGASSERT(x) assert(x)

#ifdef __weak_alias
__weak_alias(getopt,_getopt);
#endif


int	opterr = 1,		/* if error message should be printed */
	optind = 1,		/* index into parent argv vector */
	optopt,			/* character checked for validity */
	optreset;		/* reset getopt */
char	*optarg;		/* argument associated with option */

static char * _progname __P((char *));
int getopt_internal __P((int, char * const *, const char *));

static char *
_progname(nargv0)
	char * nargv0;
{
	char * tmp;

	_DIAGASSERT(nargv0 != NULL);

	tmp = strrchr(nargv0, '/');
	if (tmp)
		tmp++;
	else
		tmp = nargv0;
	return(tmp);
}

#define	BADCH	(int)'?'
#define	BADARG	(int)':'
#define	EMSG	""

/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
int
getopt(nargc, nargv, ostr)
	int nargc;
	char * const nargv[];
	const char *ostr;
{
	static char *__progname = 0;
	static char *place = EMSG;		/* option letter processing */
	char *oli;				/* option letter list index */
        __progname = __progname?__progname:_progname(*nargv);

	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(ostr != NULL);

	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc || *(place = nargv[optind]) != '-') {
			place = EMSG;
			return (-1);
		}
		if (place[1] && *++place == '-'	/* found "--" */
		    && place[1] == '\0') {
			++optind;
			place = EMSG;
			return (-1);
		}
	}					/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' ||
	    !(oli = strchr(ostr, optopt))) {
		/*
		 * if the user didn't specify '-' as an option,
		 * assume it means -1.
		 */
		if (optopt == (int)'-')
			return (-1);
		if (!*place)
			++optind;
		if (opterr && *ostr != ':')
			(void)fprintf(stderr,
			    "%s: illegal option -- %c\n", __progname, optopt);
		return (BADCH);
	}
	if (*++oli != ':') {			/* don't need argument */
		optarg = NULL;
		if (!*place)
			++optind;
	}
	else {					/* need an argument */
		if (*place)			/* no white space */
			optarg = place;
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			if (*ostr == ':')
				return (BADARG);
			if (opterr)
				(void)fprintf(stderr,
				    "%s: option requires an argument -- %c\n",
				    __progname, optopt);
			return (BADCH);
		}
	 	else				/* white space */
			optarg = nargv[optind];
		place = EMSG;
		++optind;
	}
	return (optopt);			/* dump back option letter */
}
{% endsnippet %}

{% snippet getopt_long_c %}
#pragma warning (disable : 6011 4244 4267)

/*
 * Copyright (c) 1987, 1993, 1994, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "getopt.h"

extern int	  opterr;	/* if error message should be printed */
extern int	  optind;	/* index into parent argv vector */
extern int	  optopt;	/* character checked for validity */
extern int	  optreset;	/* reset getopt */
extern char *optarg;	/* argument associated with option */

#define __P(x) x
#define _DIAGASSERT(x) assert(x)

static char * __progname __P((char *));
int getopt_internal __P((int, char * const *, const char *));

static char *
__progname(nargv0)
	char * nargv0;
{
	char * tmp;

	_DIAGASSERT(nargv0 != NULL);

	tmp = strrchr(nargv0, '/');
	if (tmp)
		tmp++;
	else
		tmp = nargv0;
	return(tmp);
}

#define	BADCH	(int)'?'
#define	BADARG	(int)':'
#define	EMSG	""

/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
int
getopt_internal(nargc, nargv, ostr)
	int nargc;
	char * const *nargv;
	const char *ostr;
{
	static char *place = EMSG;		/* option letter processing */
	char *oli;				/* option letter list index */

	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(ostr != NULL);

	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc || *(place = nargv[optind]) != '-') {
			place = EMSG;
			return (-1);
		}
		if (place[1] && *++place == '-') {	/* found "--" */
			/* ++optind; */
			place = EMSG;
			return (-2);
		}
	}					/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' ||
	    !(oli = strchr(ostr, optopt))) {
		/*
		 * if the user didn't specify '-' as an option,
		 * assume it means -1.
		 */
		if (optopt == (int)'-')
			return (-1);
		if (!*place)
			++optind;
		if (opterr && *ostr != ':')
			(void)fprintf(stderr,
			    "%s: illegal option -- %c\n", __progname(nargv[0]), optopt);
		return (BADCH);
	}
	if (*++oli != ':') {			/* don't need argument */
		optarg = NULL;
		if (!*place)
			++optind;
	} else {				/* need an argument */
		if (*place)			/* no white space */
			optarg = place;
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			if ((opterr) && (*ostr != ':'))
				(void)fprintf(stderr,
				    "%s: option requires an argument -- %c\n",
				    __progname(nargv[0]), optopt);
			return (BADARG);
		} else				/* white space */
			optarg = nargv[optind];
		place = EMSG;
		++optind;
	}
	return (optopt);			/* dump back option letter */
}

#if 0
/*
 * getopt --
 *	Parse argc/argv argument vector.
 */
int
getopt2(nargc, nargv, ostr)
	int nargc;
	char * const *nargv;
	const char *ostr;
{
	int retval;

	if ((retval = getopt_internal(nargc, nargv, ostr)) == -2) {
		retval = -1;
		++optind; 
	}
	return(retval);
}
#endif

/*
 * getopt_long --
 *	Parse argc/argv argument vector.
 */
int
getopt_long(nargc, nargv, options, long_options, index)
	int nargc;
	char ** nargv;
	const char * options;
	struct option * long_options;
	int * index;
{
	int retval;

	_DIAGASSERT(nargv != NULL);
	_DIAGASSERT(options != NULL);
	_DIAGASSERT(long_options != NULL);
	/* index may be NULL */

	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {
		char *current_argv = nargv[optind++] + 2, *has_equal;
		int i, current_argv_len, match = -1;

		if (*current_argv == '\0') {
			return(-1);
		}
		if ((has_equal = strchr(current_argv, '=')) != NULL) {
			current_argv_len = has_equal - current_argv;
			has_equal++;
		} else
			current_argv_len = strlen(current_argv);

		for (i = 0; long_options[i].name; i++) { 
			if (strncmp(current_argv, long_options[i].name, current_argv_len))
				continue;

			if (strlen(long_options[i].name) == (unsigned)current_argv_len) { 
				match = i;
				break;
			}
			if (match == -1)
				match = i;
		}
		if (match != -1) {
			if (long_options[match].has_arg == required_argument ||
			    long_options[match].has_arg == optional_argument) {
				if (has_equal)
					optarg = has_equal;
				else
					optarg = nargv[optind++];
			}
			if ((long_options[match].has_arg == required_argument)
			    && (optarg == NULL)) {
				/*
				 * Missing argument, leading :
				 * indicates no error should be generated
				 */
				if ((opterr) && (*options != ':'))
					(void)fprintf(stderr,
				      "%s: option requires an argument -- %s\n",
				      __progname(nargv[0]), current_argv);
				return (BADARG);
			}
		} else { /* No matching argument */
			if ((opterr) && (*options != ':'))
				(void)fprintf(stderr,
				    "%s: illegal option -- %s\n", __progname(nargv[0]), current_argv);
			return (BADCH);
		}
		if (long_options[match].flag) {
			*long_options[match].flag = long_options[match].val;
			retval = 0;
		} else 
			retval = long_options[match].val;
		if (index)
			*index = match;
	}
	return(retval);
}
{% endsnippet %}


{% snippet manpage %}
.TH {{ project_name }} 1 "{{ year }}"

.SH NAME
{{ project_name }} \- Generate files and projects from a standard template file.

.SH SYNOPSIS
THIS IS AN EXAMPLE PAGE

.B {{ project_name }}
[
.B -vh
] [
.B -t
.I template_file
] [
.B -f
.I flavor
] filename ...
.PP 
.B {{ project_name }}
.B -p
.I project
[
.B -t
.I template_file
] project_name ...
.PP 
.B {{ project_name }}
.B -l
[
.B -t
.I template_file
]
.PP 
.B {{ project_name }}
.B -b 
filename ...
.PP
.B {{ project_name }}
.B -s
.I snippet_name
[
.B -t
.I template_file
] project_name ...

.SH DESCRIPTION

THIS IS AN EXAMPLE PAGE

This program is used to generate individual files and entire projects from a template
file. The advantage of using templates to generate files and projects
is that it encourages a more uniform source code layout, and it
obviously saves a lot of work when starting a new project.

.SH OPTIONS
.TP
-b, --write-binary
All input files are written as a stream of hexadecimal bytes onto
standard output, so that they can be placed into the template file
either as binary files or binary snippets. This mode of operation does
not use or require any template file to be present. See the section BINARIES AND BLOBS for a more 
detailed explanation.
.TP
-f FLAVOR, --flavor=FLAVOR
Specify which flavor of template to select for a certain extension, so
you can have a .c file with a gnu flavor or a bsd flavor or whatever
you like.
.TP
-h,--help
Display the commandline help and exit sucessfully.
.TP
-l,--list
Display contents of the template file. This command does not generate any
files or projects, even if you specify them.
.TP
-p PROJECT, --project=PROJECT
Select PROJECT from the template file and generate the project under
the name of FILE, in a directory FILE.
.TP
-s SNIPPET, --snippet=SNIPPET
Prints the SNIPPET on stdout. Very useful if you have snippets for common
code situations. A good shell alias would be: 
.B alias snippet='sprot -s'
.TP
-t FILE, --template-file=FILE
Use FILE as the template file. The default template file is ~/.default.sprot.
.TP
-v,--version
This displays the version of the program. Here in the manpage there
is more room for explaining what an option does.

.SH BASIC INTRODUCTION
Your default template file containing all the templates and projects
is located in your home folder: ~/.default.sprot

The template file consist basically of a list of files seperated by
special commands, that will be used as template when you create an
individual file, or a set of files as part of a project.

First, how do templates work. You define a template like so:

bla bla bla

.SH FILE AND PROJECT STATEMENTS

bla bla bla

.SH VARIABLES

There are two kinds of variables, built-in variables and user-defined
variables. Variables can be used both in the %file% or %template% body
and also in the %file% and %binary% name, like so:

Because the template file is parsed in its entirely before file
generation takes place, there is no need to define a variable before
it is used. If you specify the same variable twice, the last of the
two values is used.

.SH SNIPPETS

A snippet is a piece of code that has an identifier and that can be
viewed as a multi-line variable. It looks like this:

.nf
snippet mysnippet%
This is just a snippet and the year is $(year).
end%
.fi

It can be called in %file% and %template% blocks as a normal variable,
in the case of the example as
.B $(mysnippet)

Another important feature of sprot is the using a 'snippet alias' in
the definition of a %file% command.

.nf
file snippet mysnippet test.cpp%
.fi

This will use snippet 'mysnippet' as the contents of the entire file,
with variable substitution inside that snippet carried out as
usual. Any contents of the %file% that would follow is ignored.

.SH BINARIES AND BLOBS

You can generate binary files with sprot, but there is no such thing
as variable substitution with binary files. An example:

.nf
blob my_blob%
01 02 03 ff fd 00
end%

binary file.bin%
00 20 30
40 12 fe
end%

binary blob my_blob my_blob.bin%
.fi

This example defines one blob (my_blob) and two binary files (file.bin and my_blob.bin).
Binaries and blobs are written as a multiline sequence
of hexadecimal bytes. You can enter this sequence manually, but
usually you will generate the hexadecimal dump of an existing binary
with the command:

.nf
sprot -b MyIcon.ico > tmp
emacs ~/.default.sprot tmp
.fi

and use your editor to copy the contents of the temporary file into
the sprot template file.

As variable substitution does not work in binary files the only way to
get the contents of a blob out is to use the 'blob alias' syntax in
the %binary% command, as shown in the last line of the example
(my_blob.bin).

.SH BUGS

* If you reference a blob or snippet in a %binary% or %file% alias and
this blob or snippet does not exist, an empty file is generated and no
warning or error is given.

.SH TODO

* A numerical prefix in projects could specify passes in the code
generation stage, and a new command %zip filename.zip% could be used
to unpack larger directory structures. Combining the two features would
enable one to unpack a skeleton zipfile and put generated files into 
that tree at a later pass.

* Sets. A new thing to generate would be 'sets' of files, for example
the generation of a .h and .cpp file when creating a class skeleton. This
should be flavored as usual, to have tc/gnu/bsd type of class skeletons.

* Multiple extensions, extension aliasses. Most pressing example would be
to have .cc files as alias for .cpp templates.

{% endsnippet %}

