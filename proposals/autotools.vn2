{% commment %}
 --- Testing utf8 source files : smiley [ ☺ ]
{% endcomment %}

{% json identity %}
{
  { "author" : "Bert van der Weerd" },
  { "email" : "bert@stanzabird.nl" },
  { "gitname" : "stanzabird" }
}
{% endjson %}



{% template "configure" %}
{% file "configure.ac" %}
AC_INIT([{{ self.project_name }}],[0.1.0],[{{ identity.email }}],[],[https://github.com/{{ identity.gitname }}/{{ self.project_name }}/])
{{ self.ac_config_srcdir }}
AC_PREREQ(2.59)
AM_INIT_AUTOMAKE
AC_CONFIG_HEADERS(config.h)
{{ self.compiler_prog }}
{{ self.ac_config_files }}
AC_OUTPUT
{% endfile %}
{% endtemplate %}





{% template "automake.shallow" extends "configure" %}
{% multiline ac_config_files %}
AC_CONFIG_FILES(Makefile)
{% endmultiline %}
{% mutiline ac_config_srcdir %}
AC_CONFIG_SRCDIR({{ self.project_name }}{{ self.src_ext }})
{% endmultiline %}
{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
bin_PROGRAMS = {{ project_name }}
{{ project_name }}_SOURCES = {{ self.project_name }}{{ self.src_ext }}
{% module man %}

man_MANS = {{ self.project_name }}.1

man :
	nroff -man {{ self.project_name }}.1 | less

EXTRA_DIST = $(man_MANS)
{% endmodule %}
{% endfile %}
{% module man %} {% file snippet manpage "${self.project_name}.1" %} {% endmodule %}
{% endtemplate %}






{% template "automake.deep" %}
{% multiline ac_config_files %}
AC_CONFIG_FILES(Makefile src/Makefile)
{% endmultiline %}
{% mutiline ac_config_srcdir %}
AC_CONFIG_SRCDIR(src/{{ self.project_name }}{{ self.src_ext }})
{% endmultiline %}
{% file "Makefile.am" %}
AUTOMAKE_OPTIONS = foreign
SUBDIRS = src
{% module vs %}
{% comment %}
  - I'm thinking only with a deep autoconf structure it kinda looks nice
    to have vs shizzle at all.
  - we need more features to support the generation of the VS project files
  - is this the right place for this module?
{% endcomment %}
EXTRA_DIST = vs/build.bat vs/src/getopt.h vs/src/getopt.c vs/src/getopt_long.c
{% endmodule %}
{% endfile %}
{% file "src/Makefile.am" %}
bin_PROGRAMS = {{ self.project_name }}
{{ self.project_name }}_SOURCES = {{ self.project_name }}{{ self.src_ext }}
{% module man %}

man_MANS = {{ self.project_name }}.1

man :
	nroff -man {{ self.project_name }}.1 | less

EXTRA_DIST = $(man_MANS)
{% endmodule %}
{% endfile %}
{% module man %} {% file snippet manpage "src/${self.project_name}.1" %} {% endmodule %}
{% endtemplate %}









{% template "shallow.c" extends "automake.shallow" %}
{% instance src_ext ".c" %}
{% instance multiline compiler_prog %}
AC_PROG_CC
{% endmultiline %}
{% file snippet simple_main_c "${self.project_name}.c" %}
{% endtemplate %}

{% template "shallow.c++" extends "automake.shallow" %}
{% instance src_ext ".cc" %}
{% instance multiline compiler_prog %}
AC_PROG_CXX
{% endmultiline %}
{% file snippet simple_main_cxx "${self.project_name}.cc" %}
{% endproject %}

{% template "deeo.c" extends "automake.deep" %}
{% instance src_ext ".c" %}
{% instance multiline compiler_prog %}
AC_PROG_CC
{% endmultiline %}
{% file snippet simple_main_c "src/${self.project_name}.c" %}
{% endtemplate %}

{% template "deep.c++" extends "automake.deep" %}
{% instance src_ext ".cc" %}
{% instance multiline compiler_prog %}
AC_PROG_CXX
{% endmultiline %}
{% file snippet simple_main_cxx "src/${self.project_name}.cc" %}
{% endproject %}












{% project "minimal.c" extends "shallow.c" %}{% endproject %}
{% project "minimal.c++" extends "shallow.c++" %}{% endproject %}

{% project "deep.c" extends "deep.c" %}{% endproject %}
{% project "deep.c++" extends "deep.c++" %}{% endproject %}
















{% commment %}

 --- In a way, these two snippets are the only actual C/C++ code that is relevant at all.. ☺

{% endcomment %}

{% snippet simple_main_c %}
#ifndef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc,char* argv[]) {
  return 0;
}
{% endsnippet %}

{% snippet simple_main_cxx %}
#ifndef HAVE_CONFIG_H
# include <config.h>
#endif

#include <iostream>
#include <vector>
#include <string>

int main(int argc,char* argv[]) {
  return 0;
}
{% endsnippet %}












{% commment %}

 --- This manpage just tries to set the bare minimum standard of what should
 go into it. It's content is garbage from a previous version of valornine.

{% endcomment %}

{% snippet manpage %}
.TH {{ self.project_name }} 1 "{{ std.year }}"

.SH NAME
{{ self.project_name }} \- Generate files and projects from a standard template file.

.SH SYNOPSIS
THIS IS AN EXAMPLE PAGE

.B {{ self.project_name }}
[
.B -vh
] [
.B -t
.I template_file
] [
.B -f
.I flavor
] filename ...
.PP 
.B {{ self.project_name }}
.B -p
.I project
[
.B -t
.I template_file
] project_name ...
.PP 
.B {{ self.project_name }}
.B -l
[
.B -t
.I template_file
]
.PP 
.B {{ self.project_name }}
.B -b 
filename ...
.PP
.B {{ self.project_name }}
.B -s
.I snippet_name
[
.B -t
.I template_file
] project_name ...

.SH DESCRIPTION

THIS IS AN EXAMPLE PAGE

This program is used to generate individual files and entire projects from a template
file. The advantage of using templates to generate files and projects
is that it encourages a more uniform source code layout, and it
obviously saves a lot of work when starting a new project.

.SH OPTIONS
.TP
-b, --write-binary
All input files are written as a stream of hexadecimal bytes onto
standard output, so that they can be placed into the template file
either as binary files or binary snippets. This mode of operation does
not use or require any template file to be present. See the section BINARIES AND BLOBS for a more 
detailed explanation.
.TP
-f FLAVOR, --flavor=FLAVOR
Specify which flavor of template to select for a certain extension, so
you can have a .c file with a gnu flavor or a bsd flavor or whatever
you like.
.TP
-h,--help
Display the commandline help and exit sucessfully.
.TP
-l,--list
Display contents of the template file. This command does not generate any
files or projects, even if you specify them.
.TP
-p PROJECT, --project=PROJECT
Select PROJECT from the template file and generate the project under
the name of FILE, in a directory FILE.
.TP
-s SNIPPET, --snippet=SNIPPET
Prints the SNIPPET on stdout. Very useful if you have snippets for common
code situations. A good shell alias would be: 
.B alias snippet='sprot -s'
.TP
-t FILE, --template-file=FILE
Use FILE as the template file. The default template file is ~/.default.sprot.
.TP
-v,--version
This displays the version of the program. Here in the manpage there
is more room for explaining what an option does.

.SH BASIC INTRODUCTION
Your default template file containing all the templates and projects
is located in your home folder: ~/.default.sprot

The template file consist basically of a list of files seperated by
special commands, that will be used as template when you create an
individual file, or a set of files as part of a project.

First, how do templates work. You define a template like so:

bla bla bla

.SH FILE AND PROJECT STATEMENTS

bla bla bla

.SH VARIABLES

There are two kinds of variables, built-in variables and user-defined
variables. Variables can be used both in the %file% or %template% body
and also in the %file% and %binary% name, like so:

Because the template file is parsed in its entirely before file
generation takes place, there is no need to define a variable before
it is used. If you specify the same variable twice, the last of the
two values is used.

.SH SNIPPETS

A snippet is a piece of code that has an identifier and that can be
viewed as a multi-line variable. It looks like this:

.nf
snippet mysnippet%
This is just a snippet and the year is $(year).
end%
.fi

It can be called in %file% and %template% blocks as a normal variable,
in the case of the example as
.B $(mysnippet)

Another important feature of sprot is the using a 'snippet alias' in
the definition of a %file% command.

.nf
file snippet mysnippet test.cpp%
.fi

This will use snippet 'mysnippet' as the contents of the entire file,
with variable substitution inside that snippet carried out as
usual. Any contents of the %file% that would follow is ignored.

.SH BINARIES AND BLOBS

You can generate binary files with sprot, but there is no such thing
as variable substitution with binary files. An example:

.nf
blob my_blob%
01 02 03 ff fd 00
end%

binary file.bin%
00 20 30
40 12 fe
end%

binary blob my_blob my_blob.bin%
.fi

This example defines one blob (my_blob) and two binary files (file.bin and my_blob.bin).
Binaries and blobs are written as a multiline sequence
of hexadecimal bytes. You can enter this sequence manually, but
usually you will generate the hexadecimal dump of an existing binary
with the command:

.nf
sprot -b MyIcon.ico > tmp
emacs ~/.default.sprot tmp
.fi

and use your editor to copy the contents of the temporary file into
the sprot template file.

As variable substitution does not work in binary files the only way to
get the contents of a blob out is to use the 'blob alias' syntax in
the %binary% command, as shown in the last line of the example
(my_blob.bin).

.SH BUGS

* If you reference a blob or snippet in a %binary% or %file% alias and
this blob or snippet does not exist, an empty file is generated and no
warning or error is given.

.SH TODO

* A numerical prefix in projects could specify passes in the code
generation stage, and a new command %zip filename.zip% could be used
to unpack larger directory structures. Combining the two features would
enable one to unpack a skeleton zipfile and put generated files into 
that tree at a later pass.

* Sets. A new thing to generate would be 'sets' of files, for example
the generation of a .h and .cpp file when creating a class skeleton. This
should be flavored as usual, to have tc/gnu/bsd type of class skeletons.

* Multiple extensions, extension aliasses. Most pressing example would be
to have .cc files as alias for .cpp templates.

{% endsnippet %}

